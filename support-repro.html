<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>swisstopo JSAPI scree repro</title>
    <link rel="stylesheet" href="https://js.arcgis.com/5.0/esri/themes/light/main.css" />
    <style>
      html,
      body,
      #viewDiv {
        margin: 0;
        width: 100%;
        height: 100%;
      }

      .panel {
        position: absolute;
        top: 12px;
        left: 12px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        padding: 10px;
        font: 12px/1.3 "Segoe UI", sans-serif;
      }

      .panel label {
        font-weight: 600;
        margin-right: 6px;
      }

      .panel select {
        font: inherit;
      }

      .status {
        margin-top: 8px;
        font-family: ui-monospace, Menlo, Consolas, monospace;
      }

      .help {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #e2e8f0;
        font-size: 11px;
        line-height: 1.35;
        color: #334155;
      }

      .help div + div {
        margin-top: 4px;
      }
    </style>
  </head>
  <body>
    <div id="viewDiv"></div>
    <div class="panel">
      <label for="mode">Mode</label>
      <select id="mode">
        <option value="upstream-noscree" selected>1) Default swisstopo upstream (Mapbox GL style)</option>
        <option value="v5-adapted">2) Adapted swisstopo style (advanced expressions refactored)</option>
        <option value="v6-scree">3) Adapted style + scree relief points</option>
        <option value="oom">4) OOM crash version</option>
      </select>
      <div class="help" id="modeHelp">
        <div><strong>1 + 2:</strong> problematic scree fill is not shown.</div>
        <div><strong>3:</strong> adapted scree rendering is enabled (split constant-pattern layers).</div>
        <div><strong>4:</strong> no scree adaptation from initial style; keeps original expression path and can trigger browser OOM.</div>
      </div>
      <div class="status" id="status">loading...</div>
    </div>

    <script type="module">
      const JSAPI = "https://js.arcgis.com/5.0";
      const UPSTREAM_STYLE_PATH = "./styles/upstream.json";
      const V5_STYLE_PATH = "./styles/v5.json";
      const V6_STYLE_PATH = "./styles/v6.json";
      const DEFAULT_CENTER = [8.595, 46.636];
      const DEFAULT_ZOOM = 13.4;

      const modeSelect = document.getElementById("mode");
      const statusEl = document.getElementById("status");

      function clone(value) {
        if (typeof structuredClone === "function") {
          return structuredClone(value);
        }
        return JSON.parse(JSON.stringify(value));
      }

      function setStatus(text) {
        statusEl.textContent = text;
      }

      async function fetchJson(path) {
        const response = await fetch(path, { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Cannot load ${path} (${response.status})`);
        }
        return response.json();
      }

      function isScreeLayer(layer) {
        return (
          layer?.type === "fill" &&
          layer?.source === "relief_v1.0.0" &&
          layer?.["source-layer"] === "scree" &&
          String(layer?.id || "").startsWith("scree_z")
        );
      }

      function removeScreeLayers(layers) {
        return (layers || []).filter((layer) => !isScreeLayer(layer));
      }

      function findInsertIndex(layers) {
        const idx = (layers || []).findIndex((layer) => layer.id === "contour_line");
        return idx >= 0 ? idx : (layers || []).length;
      }

      function andFilter(a, b) {
        if (!a) return b;
        return ["all", a, b];
      }

      function parseWeightPatternMap(expr) {
        if (!Array.isArray(expr) || expr[0] !== "match") {
          return [];
        }

        const pairs = [];
        for (let i = 2; i + 1 < expr.length; i += 2) {
          const weight = expr[i];
          const pattern = expr[i + 1];
          if (typeof weight === "number" && typeof pattern === "string" && pattern) {
            pairs.push({ weight, pattern });
          }
        }
        return pairs.sort((a, b) => b.weight - a.weight);
      }

      function extractScreeTemplates(upstreamStyle) {
        return (upstreamStyle.layers || []).filter(isScreeLayer).map((layer) => clone(layer));
      }

      function buildSplitLayersFromTemplates(screeTemplates) {
        const out = [];
        for (const template of screeTemplates) {
          const pairs = parseWeightPatternMap(template?.paint?.["fill-pattern"]);
          for (const { weight, pattern } of pairs) {
            const next = clone(template);
            next.id = `${template.id}_split_w${weight}`;
            next.filter = andFilter(template.filter, ["==", "weight", weight]);
            next.paint["fill-pattern"] = pattern;
            out.push(next);
          }
        }
        return out;
      }

      function buildModePayload(mode, styles) {
        if (mode === "upstream-noscree") {
          const style = clone(styles.upstream);
          style.layers = removeScreeLayers(style.layers);
          style.name = "upstream-noscree";
          return { style, injectedIds: [] };
        }

        if (mode === "v5-adapted") {
          const style = clone(styles.v5);
          style.name = "v5-adapted";
          return { style, injectedIds: [] };
        }

        const style = clone(styles.v6);
        const stripped = removeScreeLayers(style.layers);
        const insertAt = findInsertIndex(stripped);

        let injectedLayers = [];
        if (mode === "v6-scree") {
          injectedLayers = buildSplitLayersFromTemplates(styles.screeTemplates);
          style.name = "v6-scree";
        } else if (mode === "oom") {
          injectedLayers = styles.screeTemplates.map((layer) => clone(layer));
          style.name = "oom";
        }

        stripped.splice(insertAt, 0, ...injectedLayers);
        style.layers = stripped;
        return { style, injectedIds: injectedLayers.map((layer) => layer.id) };
      }

      try {
        const [
          { default: esriConfig },
          { default: ArcGISMap },
          { default: MapView },
          { default: VectorTileLayer },
        ] = await Promise.all([
          import(`${JSAPI}/@arcgis/core/config.js`),
          import(`${JSAPI}/@arcgis/core/Map.js`),
          import(`${JSAPI}/@arcgis/core/views/MapView.js`),
          import(`${JSAPI}/@arcgis/core/layers/VectorTileLayer.js`),
        ]);

        esriConfig.assetsPath = `${JSAPI}/@arcgis/core/assets`;

        const [upstreamStyle, v5Style, v6Style] = await Promise.all([
          fetchJson(UPSTREAM_STYLE_PATH),
          fetchJson(V5_STYLE_PATH),
          fetchJson(V6_STYLE_PATH),
        ]);

        const styles = {
          upstream: upstreamStyle,
          v5: v5Style,
          v6: v6Style,
          screeTemplates: extractScreeTemplates(upstreamStyle),
        };

        const map = new ArcGISMap({ basemap: null });
        new MapView({
          container: "viewDiv",
          map,
          center: { longitude: DEFAULT_CENTER[0], latitude: DEFAULT_CENTER[1] },
          zoom: DEFAULT_ZOOM,
        });

        let activeLayer = null;

        async function loadMode(mode) {
          setStatus(`mode=${mode} loading`);
          const { style, injectedIds } = buildModePayload(mode, styles);
          const layer = new VectorTileLayer({ style });

          if (activeLayer) {
            map.remove(activeLayer);
            activeLayer.destroy();
            activeLayer = null;
          }

          map.add(layer);
          activeLayer = layer;
          await layer.load();

          const ids = injectedIds.length ? injectedIds.join(",") : "none";
          setStatus(`mode=${mode} loaded screeLayers=${injectedIds.length} ids=${ids}`);
        }

        modeSelect.addEventListener("change", () => {
          loadMode(modeSelect.value).catch((error) => {
            setStatus(`error: ${error?.message || String(error)}`);
            console.error(error);
          });
        });

        await loadMode(modeSelect.value);
      } catch (error) {
        setStatus(`error: ${error?.message || String(error)}`);
        console.error(error);
      }
    </script>
  </body>
</html>
